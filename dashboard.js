require('dotenv').config();
const fs = require('fs');
const csv = require('csv-parser');
const blessed = require('blessed');
const contrib = require('blessed-contrib');
const { Mistral } = require('@mistralai/mistralai');

// Check Mistral AI Key
const apiKey = process.env.MISTRAL_API_KEY;
if (!apiKey) {
    console.error("MISTRAL_API_KEY not found in .env. Please set it and run again.");
    process.exit(1);
}

const client = new Mistral({ apiKey });

// Import C++ math engine
let kalmanMath;
try {
    kalmanMath = require('./build/Release/kalman_math.node');
} catch (err) {
    console.error("Could not load native module `kalman_math.node`: " + err.message);
    process.exit(1);
}

// Initial Kalman Filter State
let state = {
    x: 0.0,
    P: 1.0,
    Q: 0.002,
    R: 1.5,
    wear_rate: 0.045
};

// UI SETUP (Blessed)
const screen = blessed.screen({
    smartCSR: true,
    title: 'F1 Pit Wall Strategist Dashboard'
});

const grid = new contrib.grid({ rows: 12, cols: 12, screen: screen });

// Window 1 (Left): Raw Telemetry Log
const telemetryLog = grid.set(0, 0, 12, 6, contrib.log, {
    fg: 'green',
    label: 'Raw Telemetry Stream',
    height: '100%',
    width: '100%',
    border: { type: 'line', fg: 'cyan' }
});

// Window 3 (Right Top): Agent Terminal Log
const agentTerminal = grid.set(0, 6, 6, 6, contrib.log, {
    fg: 'yellow',
    label: 'Agent Terminal (Pit Strategist)',
    height: '100%',
    width: '100%',
    border: { type: 'line', fg: 'yellow' }
});

// Window 2 (Right Bottom): Line Chart for Tire Degradation and Cliff Prob
const lineChart = grid.set(6, 6, 6, 6, contrib.line, {
    label: 'Tire State vs Laps',
    showLegend: true,
    legend: { width: 14 },
    style: {
        line: 'red',
        text: 'white',
        baseline: 'black'
    },
    xLabelPadding: 3,
    xPadding: 5,
    showNumb: true,
    numStyle: 'yellow'
});

// To view "Wear (s)" and "Cliff Prob %" on the same chart logically,
// We will scale "Wear" by a factor of 100 on the graph view so it visually aligns with % Prob,
// or we keep them on different lines. Since Blessedcontrib scales globally, we'll scale wear by 100.
const wearSeries = {
    title: 'Wear (sx100)',
    x: [],
    y: [],
    style: { line: 'red' }
};

const cliffSeries = {
    title: 'Cliff Prob %',
    x: [],
    y: [],
    style: { line: 'magenta' }
};

// Key binding to quit
screen.key(['escape', 'q', 'C-c'], function (ch, key) {
    return process.exit(0);
});

screen.render();

const CSV_FILE = 'belgian_gp_HAM_telemetry.csv';

// State variables for tracking
let isAgentThinking = false;
let lastDecisionLap = -5; // prevent immediate double trigger
let currentLap = 0;
let executePitStop = false;

function wrapAndLog(terminal, text, maxWidth = 45) {
    if (!text) return;
    const lines = text.split('\n');
    for (const line of lines) {
        const words = line.split(' ');
        let currentLine = '';
        for (const word of words) {
            if ((currentLine + word).length > maxWidth) {
                terminal.log(currentLine);
                currentLine = word + ' ';
            } else {
                currentLine += word + ' ';
            }
        }
        if (currentLine.trim()) terminal.log(currentLine.trim());
    }
}

function handleAiDecision(lap, dropObj, currentP, currentCliff) {
    if (isAgentThinking) return;

    if (currentCliff > 0.70 || (lap > 0 && lap % 5 === 0)) {
        if (lap - lastDecisionLap < 2) return;

        lastDecisionLap = lap;
        isAgentThinking = true;
        agentTerminal.log(`\n[Lap ${lap}] ðŸš¨ Critical state detected (Cliff: ${(currentCliff * 100).toFixed(1)}%). Triggering Mistral API...`);
        screen.render();

        const prompt = `You are the lead race strategist for an F1 team. Analyze the following telemetry summary generated by our C++ math engine. Output a short, analytical recommendation (max 3 sentences) on whether we should pit now or stay out, and which tire compound to use next. You must return a valid JSON object with EXACTLY three keys: "decision" (string: "BOX" or "STAY"), "confidence" (number between 0.0 and 1.0), and "reasoning" (string: your explanation).

CRITICAL STRATEGY RULES:
- Do NOT PIT (choose 'STAY') if the Cliff Probability is low (under 60%). Tires usually last 15-25 laps; boxing early ruins the race.
- ONLY choose 'BOX' if Cliff Probability is dangerously high (e.g., > 70%) or if the True Wear indicates a severe loss of grip.

Telemetry Data:
- Lap: ${lap}
- Current True Wear (Smoothed): ${dropObj.toFixed(3)}s
- Cliff Probability: ${(currentCliff * 100).toFixed(1)}%`;

        client.chat.complete({
            model: 'mistral-large-latest',
            messages: [{ role: 'system', content: prompt }],
            responseFormat: { type: 'json_object' }
        }).then(res => {
            try {
                const responseContent = res.choices[0].message.content;
                const parsed = JSON.parse(responseContent);
                const reasoning = parsed.reasoning || parsed.Reasoning || "No reasoning provided by agent.";
                agentTerminal.log(``); // padding line
                agentTerminal.log(`\x1b[4m>>> STRATEGY (Lap ${lap}) <<<\x1b[0m`);
                agentTerminal.log(`Cliff Check: ${(currentCliff * 100).toFixed(1)}%`);
                agentTerminal.log(`Decision:   \x1b[35m${parsed.decision}\x1b[0m`);
                agentTerminal.log(`Confidence: \x1b[36m${(parsed.confidence * 100).toFixed(1)}%\x1b[0m`);
                agentTerminal.log(`Reasoning:`);
                wrapAndLog(agentTerminal, reasoning, 45);
                agentTerminal.log(`-----------------------------`);

                if (parsed.decision === 'BOX') {
                    executePitStop = true;
                }
            } catch (err) {
                // In case the API returns JSON with some surrounding markdown
                try {
                    const extractJson = responseContent.match(/\{[\s\S]*\}/)[0];
                    const parsedFallback = JSON.parse(extractJson);
                    const reasoningFallback = parsedFallback.reasoning || parsedFallback.Reasoning || "No reasoning provided by agent.";
                    agentTerminal.log(``); // padding line
                    agentTerminal.log(`\x1b[4m>>> STRATEGY (Lap ${lap}) <<<\x1b[0m`);
                    agentTerminal.log(`Cliff Check: ${(currentCliff * 100).toFixed(1)}%`);
                    agentTerminal.log(`Decision:   \x1b[35m${parsedFallback.decision}\x1b[0m`);
                    agentTerminal.log(`Confidence: \x1b[36m${(parsedFallback.confidence * 100).toFixed(1)}%\x1b[0m`);
                    agentTerminal.log(`Reasoning:`);
                    wrapAndLog(agentTerminal, reasoningFallback, 45);
                    agentTerminal.log(`-----------------------------`);

                    if (parsedFallback.decision === 'BOX') {
                        executePitStop = true;
                    }
                } catch (fallbackErr) {
                    agentTerminal.log(`[Error parsing API response]: ${err.message}`);
                    agentTerminal.log(`Raw Response: ${responseContent}`);
                }
            }
            screen.render();
        }).catch(err => {
            agentTerminal.log(`[Mistral API Error]: ${err.message}`);
            screen.render();
        }).finally(() => {
            isAgentThinking = false;
        });
    }
}

function startRaceSimulation() {
    const telemetryStream = [];

    if (!fs.existsSync(CSV_FILE)) {
        console.error("CSV File not found: " + CSV_FILE);
        process.exit(1);
    }

    fs.createReadStream(CSV_FILE)
        .pipe(csv())
        .on('data', (row) => telemetryStream.push(row))
        .on('end', () => {
            telemetryLog.log('--- Telemetry Loaded. Starting Live Race Simulation ---');
            screen.render();

            const interval = setInterval(() => {
                if (currentLap >= telemetryStream.length) {
                    clearInterval(interval);
                    telemetryLog.log('--- Race Finished ---');
                    telemetryLog.log('Press [ESC], [Q], or [CTRL-C] to exit.');
                    screen.render();
                    return;
                }

                const rawData = telemetryStream[currentLap];
                const actualLap = Math.round(parseFloat(rawData.LapNumber));
                const lapNumStr = actualLap.toString().padStart(2, '0');
                const degradationDelta = parseFloat(rawData.Degradation_Delta);

                if (executePitStop) {
                    // Pit stop commanded by Agent, reset tire degradation state
                    state.x = 0.0;
                    state.P = 1.0;
                    telemetryLog.log('');
                    telemetryLog.log(`\x1b[33m--- PIT STOP: Tires Changed (Agent Decision) ---\x1b[0m`);
                    telemetryLog.log('');
                    executePitStop = false;
                }

                if (!isNaN(degradationDelta)) {
                    // C++ Update
                    const result = kalmanMath.updateState(
                        state.x, state.P, state.Q, state.R, state.wear_rate, degradationDelta
                    );

                    state.x = result.x;
                    state.P = result.P;

                    // Log to Windows 1
                    telemetryLog.log(`Lap ${lapNumStr} | Raw Drop: ${degradationDelta.toFixed(3)}s | True Wear: ${result.x.toFixed(3)}s | Cliff: ${(result.cliffProb * 100).toFixed(1)}%`);

                    // Update Chart Data
                    wearSeries.x.push(lapNumStr);
                    wearSeries.y.push(result.x * 100);

                    cliffSeries.x.push(lapNumStr);
                    cliffSeries.y.push(result.cliffProb * 100);

                    if (wearSeries.x.length > 20) {
                        wearSeries.x.shift();
                        wearSeries.y.shift();
                        cliffSeries.x.shift();
                        cliffSeries.y.shift();
                    }

                    lineChart.setData([wearSeries, cliffSeries]);

                    // Trigger AI
                    handleAiDecision(actualLap, result.x, result.P, result.cliffProb);

                    screen.render();
                }
                currentLap++;
            }, 1000); // 1 sec stream
        })
        .on('error', (err) => {
            console.error("Error reading CSV:", err);
            process.exit(1);
        });
}

startRaceSimulation();
